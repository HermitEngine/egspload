// This file is automatically generated by egsploader.

#ifndef EGSPLOAD_H
#define EGSPLOAD_H

#include "egsplib.h"

static EgspResult _EgspLoadInnerStruct(EgspLoader* pLoader, InnerStruct* pVal)
{
	uint8_t egspNullCheck = 0;
	EGSP_TRY(_EgspLoaduint64_t(pLoader, &pVal->dummy));
	return EGSP_SUCCESS;
}

static EgspResult EgspLoadInnerStruct(EgspFunc pLoadFunc, InnerStruct* pVal, void* pHeap, size_t heapSize)
{
	EgspLoader loader;
	loader.pFunc = pLoadFunc;
	loader.offset = 0;
	loader.pHeap = pHeap;
	loader.heapSize = heapSize;
	EGSP_TEST(loader.pData = loader.pFunc(EgspBlockSize()));
	EGSP_TRY(_EgspLoadInnerStruct(&loader, pVal));
	return EGSP_SUCCESS;
}

static EgspResult _EgspSaveInnerStruct(EgspLoader* pLoader, InnerStruct* pVal)
{
	EGSP_TRY(_EgspSaveuint64_t(pLoader, &pVal->dummy));
	return EGSP_SUCCESS;
}

static EgspResult EgspSaveInnerStruct(EgspFunc pFlushFunc, InnerStruct* pVal, size_t* pHeapRequired)
{
	EgspLoader loader;
	loader.pFunc = pFlushFunc;
	loader.offset = 0;
	loader.heapSize = 0;
	EGSP_TEST(loader.pData = loader.pFunc(0));
	EGSP_TRY(_EgspSaveInnerStruct(&loader, pVal))
;	EGSP_TRY(EgspFlush(&loader));
	*pHeapRequired = loader.heapSize;
	return EGSP_SUCCESS;
}

static EgspResult _EgspPrintInnerStruct(EgspLoader* pLoader, InnerStruct* pVal)
{
	EGSP_TRY(_EgspWriteString(pLoader, "{"));
	EGSP_TRY(_EgspWriteString(pLoader, "\"dummy\":"));
	EGSP_TRY(_EgspPrintuint64_t(pLoader, &pVal->dummy));
	return _EgspWriteString(pLoader, "},");
}

static EgspResult EgspPrintInnerStruct(EgspFunc pFlushFunc, InnerStruct* pVal, size_t* pHeapRequired)
{
	EgspLoader loader;
	loader.pFunc = pFlushFunc;
	loader.offset = 0;
	loader.heapSize = 0;
	loader.last = 0;
	loader.indent = 0;
	EGSP_TEST(loader.pData = loader.pFunc(EgspBlockSize()));
	EGSP_TRY(_EgspPrintInnerStruct(&loader, pVal));
	EGSP_TRY(EgspFlush(&loader));
	*pHeapRequired = loader.heapSize;
	return EGSP_SUCCESS;
}

static EgspResult _EgspReadInnerStruct(EgspLoader* pLoader, InnerStruct* pVal)
{
	uint8_t egspNullCheck = 0;
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReaduint64_t(pLoader, &pVal->dummy));
	return EGSP_SUCCESS;
}

static EgspResult EgspReadInnerStruct(EgspFunc pLoadFunc, InnerStruct* pVal, void* pHeap, size_t heapSize)
{
	EgspLoader loader;
	loader.pFunc = pLoadFunc;
	loader.offset = 0;
	loader.pHeap = pHeap;
	loader.heapSize = heapSize;
	EGSP_TEST(loader.pData = loader.pFunc(0));
	EGSP_TRY(_EgspReadInnerStruct(&loader, pVal));
	return EGSP_SUCCESS;
}

static EgspResult _EgspLoadTestStruct(EgspLoader* pLoader, TestStruct* pVal)
{
	uint8_t egspNullCheck = 0;
	EGSP_TRY(_EgspLoaduint32_t(pLoader, &pVal->testint));
	EGSP_TRY(_EgspLoadfloat(pLoader, &pVal->testfloat));
	EGSP_TRY(_EgspLoadint16_t(pLoader, &pVal->testsigned));
	EGSP_TRY(_EgspLoaduint32_t(pLoader, &pVal->structcount));
	if (pVal->teststruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct)) * pVal->structcount))
	{
		for (size_t i = 0; i < pVal->structcount; ++i)
		{
			EGSP_TRY(_EgspLoadInnerStruct(pLoader, pVal->teststruct + i));
		}
	}
	EGSP_TRY(_EgspLoaduint8_t(pLoader, &egspNullCheck));
	if (egspNullCheck)
	{
		EGSP_TEST(pVal->pointerstruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct))))
		EGSP_TRY(_EgspLoadInnerStruct(pLoader, pVal->pointerstruct));
	}
	else
	{
		pVal->pointerstruct = 0;
	}
	EGSP_TRY(_EgspLoaduint8_t(pLoader, &egspNullCheck));
	if (egspNullCheck)
	{
		EGSP_TEST(pVal->nullstruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct))))
		EGSP_TRY(_EgspLoadInnerStruct(pLoader, pVal->nullstruct));
	}
	else
	{
		pVal->nullstruct = 0;
	}
	EGSP_TRY(_EgspLoadInnerStruct(pLoader, &pVal->inlinestruct));
	EGSP_TRY(_EgspLoadstring(pLoader, &pVal->TestString));
	{
		int32_t enumval = 0;
		EGSP_TRY(_EgspLoadint32_t(pLoader, &enumval));
		pVal->testenum = (TestEnum) enumval;
	}
	return EGSP_SUCCESS;
}

static EgspResult EgspLoadTestStruct(EgspFunc pLoadFunc, TestStruct* pVal, void* pHeap, size_t heapSize)
{
	EgspLoader loader;
	loader.pFunc = pLoadFunc;
	loader.offset = 0;
	loader.pHeap = pHeap;
	loader.heapSize = heapSize;
	EGSP_TEST(loader.pData = loader.pFunc(EgspBlockSize()));
	EGSP_TRY(_EgspLoadTestStruct(&loader, pVal));
	return EGSP_SUCCESS;
}

static EgspResult _EgspSaveTestStruct(EgspLoader* pLoader, TestStruct* pVal)
{
	EGSP_TRY(_EgspSaveuint32_t(pLoader, &pVal->testint));
	EGSP_TRY(_EgspSavefloat(pLoader, &pVal->testfloat));
	EGSP_TRY(_EgspSaveint16_t(pLoader, &pVal->testsigned));
	EGSP_TRY(_EgspSaveuint32_t(pLoader, &pVal->structcount));
	pLoader->heapSize += EgspPad(sizeof(*pVal->teststruct)) * pVal->structcount;
	for (size_t i = 0; i < pVal->structcount; ++i)
	{
		EGSP_TRY(_EgspSaveInnerStruct(pLoader, pVal->teststruct + i));
	}
	if (pVal->pointerstruct)
	{
		pLoader->heapSize += EgspPad(sizeof(*pVal->pointerstruct));
		uint8_t nullInd = 1;
		EGSP_TRY(_EgspSaveuint8_t(pLoader, &nullInd));
		EGSP_TRY(_EgspSaveInnerStruct(pLoader, pVal->pointerstruct));
	}
	else
	{
		uint8_t nullInd = 0;
		EGSP_TRY(_EgspSaveuint8_t(pLoader, &nullInd));
	}
	if (pVal->nullstruct)
	{
		pLoader->heapSize += EgspPad(sizeof(*pVal->nullstruct));
		uint8_t nullInd = 1;
		EGSP_TRY(_EgspSaveuint8_t(pLoader, &nullInd));
		EGSP_TRY(_EgspSaveInnerStruct(pLoader, pVal->nullstruct));
	}
	else
	{
		uint8_t nullInd = 0;
		EGSP_TRY(_EgspSaveuint8_t(pLoader, &nullInd));
	}
	EGSP_TRY(_EgspSaveInnerStruct(pLoader, &pVal->inlinestruct));
	EGSP_TRY(_EgspSavestring(pLoader, &pVal->TestString));
	{
		int32_t enumval = pVal->testenum;
	EGSP_TRY(_EgspSaveint32_t(pLoader, &enumval));
	}
	return EGSP_SUCCESS;
}

static EgspResult EgspSaveTestStruct(EgspFunc pFlushFunc, TestStruct* pVal, size_t* pHeapRequired)
{
	EgspLoader loader;
	loader.pFunc = pFlushFunc;
	loader.offset = 0;
	loader.heapSize = 0;
	EGSP_TEST(loader.pData = loader.pFunc(0));
	EGSP_TRY(_EgspSaveTestStruct(&loader, pVal))
;	EGSP_TRY(EgspFlush(&loader));
	*pHeapRequired = loader.heapSize;
	return EGSP_SUCCESS;
}

static EgspResult _EgspPrintTestStruct(EgspLoader* pLoader, TestStruct* pVal)
{
	EGSP_TRY(_EgspWriteString(pLoader, "{"));
	EGSP_TRY(_EgspWriteString(pLoader, "\"testint\":"));
	EGSP_TRY(_EgspPrintuint32_t(pLoader, &pVal->testint));
	EGSP_TRY(_EgspWriteString(pLoader, "\"testfloat\":"));
	EGSP_TRY(_EgspPrintfloat(pLoader, &pVal->testfloat));
	EGSP_TRY(_EgspWriteString(pLoader, "\"testsigned\":"));
	EGSP_TRY(_EgspPrintint16_t(pLoader, &pVal->testsigned));
	EGSP_TRY(_EgspWriteString(pLoader, "\"structcount\":"));
	EGSP_TRY(_EgspPrintuint32_t(pLoader, &pVal->structcount));
	pLoader->heapSize += EgspPad(sizeof(*pVal->teststruct)) * pVal->structcount;
	EGSP_TRY(_EgspWriteString(pLoader, "\"teststruct\":["));
	for (size_t i = 0; i < pVal->structcount; ++i)
	{
		EGSP_TRY(_EgspPrintInnerStruct(pLoader, pVal->teststruct + i));
	}
	EGSP_TRY(_EgspWriteString(pLoader, "],"))
	if (pVal->pointerstruct)
	{
		pLoader->heapSize += EgspPad(sizeof(*pVal->pointerstruct));
		uint8_t nullInd = 1;
		EGSP_TRY(_EgspWriteString(pLoader, "\"pointerstruct is not null. Processing\":"));
		EGSP_TRY(_EgspPrintuint8_t(pLoader, &nullInd));
		EGSP_TRY(_EgspWriteString(pLoader, "\"pointerstruct\":"));
		EGSP_TRY(_EgspPrintInnerStruct(pLoader, pVal->pointerstruct))
	}
	else
	{
		uint8_t nullInd = 0;
		EGSP_TRY(_EgspWriteString(pLoader, "\"pointerstruct is null. Skipping.\":"));
		EGSP_TRY(_EgspPrintuint8_t(pLoader, &nullInd));
	}
	if (pVal->nullstruct)
	{
		pLoader->heapSize += EgspPad(sizeof(*pVal->nullstruct));
		uint8_t nullInd = 1;
		EGSP_TRY(_EgspWriteString(pLoader, "\"nullstruct is not null. Processing\":"));
		EGSP_TRY(_EgspPrintuint8_t(pLoader, &nullInd));
		EGSP_TRY(_EgspWriteString(pLoader, "\"nullstruct\":"));
		EGSP_TRY(_EgspPrintInnerStruct(pLoader, pVal->nullstruct))
	}
	else
	{
		uint8_t nullInd = 0;
		EGSP_TRY(_EgspWriteString(pLoader, "\"nullstruct is null. Skipping.\":"));
		EGSP_TRY(_EgspPrintuint8_t(pLoader, &nullInd));
	}
	EGSP_TRY(_EgspWriteString(pLoader, "\"inlinestruct\":"));
	EGSP_TRY(_EgspPrintInnerStruct(pLoader, &pVal->inlinestruct));
	EGSP_TRY(_EgspWriteString(pLoader, "\"TestString\":"));
	EGSP_TRY(_EgspPrintstring(pLoader, &pVal->TestString));
	{
		int32_t enumval = pVal->testenum;
		EGSP_TRY(_EgspWriteString(pLoader, "\"testenum\":"));
		EGSP_TRY(_EgspPrintint32_t(pLoader, &enumval));
	}
	return _EgspWriteString(pLoader, "},");
}

static EgspResult EgspPrintTestStruct(EgspFunc pFlushFunc, TestStruct* pVal, size_t* pHeapRequired)
{
	EgspLoader loader;
	loader.pFunc = pFlushFunc;
	loader.offset = 0;
	loader.heapSize = 0;
	loader.last = 0;
	loader.indent = 0;
	EGSP_TEST(loader.pData = loader.pFunc(EgspBlockSize()));
	EGSP_TRY(_EgspPrintTestStruct(&loader, pVal));
	EGSP_TRY(EgspFlush(&loader));
	*pHeapRequired = loader.heapSize;
	return EGSP_SUCCESS;
}

static EgspResult _EgspReadTestStruct(EgspLoader* pLoader, TestStruct* pVal)
{
	uint8_t egspNullCheck = 0;
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReaduint32_t(pLoader, &pVal->testint));
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReadfloat(pLoader, &pVal->testfloat));
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReadint16_t(pLoader, &pVal->testsigned));
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReaduint32_t(pLoader, &pVal->structcount));
	if (pVal->teststruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct)) * pVal->structcount))
	{
		EGSP_TRY(_EgspSkipLabel(pLoader));
		for (size_t i = 0; i < pVal->structcount; ++i)
		{
			EGSP_TRY(_EgspReadInnerStruct(pLoader, pVal->teststruct + i));
		}
	}
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReaduint8_t(pLoader, &egspNullCheck));
	if (egspNullCheck)
	{
		EGSP_TEST(pVal->pointerstruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct))))
		EGSP_TRY(_EgspSkipLabel(pLoader));
		EGSP_TRY(_EgspReadInnerStruct(pLoader, pVal->pointerstruct));
	}
	else
	{
		pVal->pointerstruct = 0;
	}
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReaduint8_t(pLoader, &egspNullCheck));
	if (egspNullCheck)
	{
		EGSP_TEST(pVal->nullstruct = EgspAlloc(pLoader, EgspPad(sizeof(InnerStruct))))
		EGSP_TRY(_EgspSkipLabel(pLoader));
		EGSP_TRY(_EgspReadInnerStruct(pLoader, pVal->nullstruct));
	}
	else
	{
		pVal->nullstruct = 0;
	}
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReadInnerStruct(pLoader, &pVal->inlinestruct));
	EGSP_TRY(_EgspSkipLabel(pLoader));
	EGSP_TRY(_EgspReadstring(pLoader, &pVal->TestString));
	{
		int32_t enumval = 0;
		EGSP_TRY(_EgspSkipLabel(pLoader));
		EGSP_TRY(_EgspReadint32_t(pLoader, &enumval));
		pVal->testenum = (TestEnum) enumval;
	}
	return EGSP_SUCCESS;
}

static EgspResult EgspReadTestStruct(EgspFunc pLoadFunc, TestStruct* pVal, void* pHeap, size_t heapSize)
{
	EgspLoader loader;
	loader.pFunc = pLoadFunc;
	loader.offset = 0;
	loader.pHeap = pHeap;
	loader.heapSize = heapSize;
	EGSP_TEST(loader.pData = loader.pFunc(0));
	EGSP_TRY(_EgspReadTestStruct(&loader, pVal));
	return EGSP_SUCCESS;
}

#endif